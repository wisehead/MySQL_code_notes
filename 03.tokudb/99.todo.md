```cpp
* db_put/ha_tokudb::read_range_first
* toku_txn_begin_with_xid
* toku_rollback_commit
* toku_rollback_abort
* toku_maybe_spill_rollbacks
* toku_txn_reads_txnid
* le_iterate_val
* toku_ft_create
* toku_ft_root_put_msg
* push_something_in_subtree
* 函数inject_message_in_locked_node实现了把message push到node节点上。伪代码如下：
* toku_ftnode_put_msg
* toku_ftnode_which_child
* toku_ft_bn_apply_msg
* toku_ft_bn_apply_msg_once是toku_le_apply_msg的简单封装
* toku_ft_root_put_msg
* toku_bnc_flush_to_child
	* toku_ftnode_put_msg
* toku_ftnode_leaf_rebalance
* toku_ft_search--> ft_search_node--> ft_search_child/ft_search_basement_node
* toku_pin_ftnode_for_query 
```



#2.Internal Node
在内存中，TokuDB内节点(internal node)的每个message buffer都有２个重要数据结构：

1) FIFO结构，保存{key, value} 2) OMT结构，保存{key, FIFO-offset} 由于FIFO不具备快速查找特性，就利用OMT来做快速查找(根据key查到value)。

这样，当内节点发生cache miss的时候，索引层需要做：

1) 从磁盘读取节点内容到内存 2) 构造FIFO结构 3) 根据FIFO构造OMT结构(做排序) 由于TokuDB内部有不少性能探(ji)针(shu)，他们发现步骤3)是个不小的性能消耗点，因为每次都要把message buffer做下排序构造出OMT，于是在7.5.0版本，把OMT的FIFO-offset(已排序)也持久化到磁盘，这样排序的损耗就没了。

#3. redo and undo

```cpp
toku_log_enq_insert

```
