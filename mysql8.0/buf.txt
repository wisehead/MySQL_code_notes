1.get_page可以通过get_frame获取到裸数据
1202         bitmap_page = buf_block_get_frame(
1203             buf_page_get_gen(
1204                 space, zip_size,
1205                 ibuf_bitmap_page_no_calc(zip_size, page_no),
1206                 RW_NO_LATCH, NULL, BUF_GET_NO_LATCH,
1207                 file, line, &local_mtr));

2.get_page 宏定义
#ifndef UNIV_HOTBACKUP
/**************************************************************//**
NOTE! The following macros should be used instead of buf_page_get_gen,
to improve debugging. Only values RW_S_LATCH and RW_X_LATCH are allowed
in LA! */
#define buf_page_get(SP, ZS, OF, LA, MTR)    buf_page_get_gen(\                                                                                                                                                                                                 
                SP, ZS, OF, LA, NULL,\
                BUF_GET, __FILE__, __LINE__, MTR)
/**************************************************************//**
Use these macros to bufferfix a page with no latching. Remember not to
read the contents of the page unless you know it is safe. Do not modify
the contents of the page! We have separated this case, because it is
error-prone programming not to set a latch, and it should be used
with care. */
#define buf_page_get_with_no_latch(SP, ZS, OF, MTR)    buf_page_get_gen(\
                SP, ZS, OF, RW_NO_LATCH, NULL,\
                BUF_GET_NO_LATCH, __FILE__, __LINE__, MTR)
                
                
3.buf_page_get_gen

/********************************************************************//**
This is the general function used to get access to a database page.
@return pointer to the block or NULL */
UNIV_INTERN
buf_block_t*
buf_page_get_gen(
/*=============*/
    ulint       space,  /*!< in: space id */
    ulint       zip_size,/*!< in: compressed page size in bytes
                or 0 for uncompressed pages */
    ulint       offset, /*!< in: page number */
    ulint       rw_latch,/*!< in: RW_S_LATCH, RW_X_LATCH, RW_NO_LATCH */
    buf_block_t*    guess,  /*!< in: guessed block or NULL */
    ulint       mode,   /*!< in: BUF_GET, BUF_GET_IF_IN_POOL,
                BUF_PEEK_IF_IN_POOL, BUF_GET_NO_LATCH, or
                BUF_GET_IF_IN_POOL_OR_WATCH */
    const char* file,   /*!< in: file name */
    ulint       line,   /*!< in: line where called */
    mtr_t*      mtr)    /*!< in: mini-transaction */
{}   
    
4. buf_page_get_with_no_latch//凑参数
    
table_space 6
page_no 3
zip_size = 0
FIL_PAGE_TYPE = 0x45 bf(17855)              

5.mtr of buf_page_get_gen
mtr_t   local_mtr;

1187 #ifdef UNIV_DEBUG
1188     if (!x_latch) {
1189         mtr_start(&local_mtr);
1190              
1191         /* Get the bitmap page without a page latch, so that
1192         we will not be violating the latching order when
1193         another bitmap page has already been latched by this
1194         thread. The page will be buffer-fixed, and thus it
1195         cannot be removed or relocated while we are looking at
1196         it. The contents of the page could change, but the
1197         IBUF_BITMAP_IBUF bit that we are interested in should
1198         not be modified by any other thread. Nobody should be
1199         calling ibuf_add_free_page() or ibuf_remove_free_page()
1200         while the page is linked to the insert buffer b-tree. */
1201              
1202         bitmap_page = buf_block_get_frame(
1203             buf_page_get_gen(
1204                 space, zip_size,
1205                 ibuf_bitmap_page_no_calc(zip_size, page_no),
1206                 RW_NO_LATCH, NULL, BUF_GET_NO_LATCH,
1207                 file, line, &local_mtr));
1208              
1209         ret = ibuf_bitmap_page_get_bits_low(
1210             bitmap_page, page_no, zip_size,
1211             MTR_MEMO_BUF_FIX, &local_mtr, IBUF_BITMAP_IBUF);
1212              
1213         mtr_commit(&local_mtr);                                                                                                                                                                                                                            
1214         return(ret);
1215     }        
1216 #endif /* UNIV_DEBUG */

以上是MySQL5.6
-==-------------------------------------------------------------------------
以下是MySQL8.0

1.buf_page_get
buf_page_get
--buf_page_get_gen
example:

 9030 /** Print the extent descriptor pages of this tablespace into
 9031 the given file.              
 9032 @param[in]  out the output file name.
 9033 @return the output stream. */
 9034 std::ostream &fil_space_t::print_xdes_pages(std::ostream &out) const {
 9035   mtr_t mtr;        
 9036   const page_size_t page_size(flags);
 9037         
 9038   mtr_start(&mtr);  
 9039         
 9040   for (page_no_t i = 0; i < 100; ++i) {
 9041     page_no_t xdes_page_no = i * UNIV_PAGE_SIZE;
 9042         
 9043     if (xdes_page_no >= size) {                                   
 9044       break;
 9045     }   
 9046         
 9047     buf_block_t *xdes_block =                                     
 9048         buf_page_get(page_id_t(id, xdes_page_no), page_size, RW_S_LATCH, &mtr);
 9049         
 9050     page_t *page = buf_block_get_frame(xdes_block);
 9051         
 9052     ulint page_type = fil_page_get_type(page);
 9053         
 9054     switch (page_type) {
 9055       case FIL_PAGE_TYPE_ALLOCATED:
 9056         
 9057         ut_ad(xdes_page_no >= free_limit);
 9058         
 9059         mtr_commit(&mtr);
 9060         return (out);
 9061         
 9062       case FIL_PAGE_TYPE_FSP_HDR:
 9063       case FIL_PAGE_TYPE_XDES:
 9064         break;
 9065       default:
 9066         ut_error;
 9067     }   
 9068         
 9069     xdes_page_print(out, page, xdes_page_no, &mtr);
 9070   }     
 9071         
 9072   mtr_commit(&mtr);
 9073   return (out);
 9074 }  
 
2.缓冲区缓冲的页类型
索引页，数据页，undo页，插入缓存(insert buffer)，自适应哈希(adaptive hash index)、锁信息（lock info）

锁信息：
每个事务锁的信息是在trx_struct对象的lock_heap变量中进行分配的。而由于mem_heap_t的特性，当申请的空间大于8KB时候，就会从缓冲池分配。

ADI，lock info不进入LRU

3.LRU算法
buffer_pool->LRU_old指向LRU链表长度的3/8处。
疑问：到底是3/8 new，还是 3/8 old。

4.LRU链表维护
关键数据结构：
--buf_pool->freeed_page_clock:每次page从bp中被换出时候，该值加1. block->freed_page_clock表示上次将page移动到LRU首部的时候，buf_pool->freed_page_clock的值。
--buf_pool->ulint_clock每个页放入bp的时间，从而知道page在热端的位置，是否为热端最活跃的page。

当页已经被读到buffer pool，那么当再次被读取时，需要维护该页在LRU链表中的位置。这个操作由 buf_block_make_young完成。
然而，并不是每次读取到页都需要放入到LRU链表的首部。若页已经处于一个比较活跃的位置，也就是LRU链表的前端部分，则不需要进行移动。

if (buf_pool->freed_page_clock >= block->freed_page_clock + 1 + (buf_pool->cur_size / 1024))
{	
	buf_LRU_make_block_young(block);
}


每次往bp增加一个page，buf_pool->ulint_clock都会+1. 同时block->LRU_position会记录当前的ulint_clock的值。
LRU_position值越大说明page在bp中的活跃度越高，被替换出去的概率越小。

在热端，LRU_position从头部到LRU_old的块是依次递减的。而在冷端的块，LRU_position的值都相同。（疑问：为啥都一样？？？？）

当page被flush到磁盘后，会将page移到LRU尾端。表示可以从LRU链表中被替换，函数buf_LRU_make_block_old()实现。















