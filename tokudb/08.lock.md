#<center>lock</center>
#1.locktree_manager::check_current_lock_constraints

```cpp
caller:
--locktree::try_acquire_lock

        // effect: Determines if too many locks or too much memory is being used,
        //         Runs escalation on the manager if so.
        // param: big_txn, if the current transaction is 'big' (has spilled rollback logs)
        // returns: 0 if there enough resources to create a new lock, or TOKUDB_OUT_OF_LOCKS
        //          if there are not enough resources and lock escalation failed to free up
        //          enough resources for a new lock.
        int check_current_lock_constraints(bool big_txn);
        
locktree_manager::check_current_lock_constraints
--over_big_threshold
--run_escalation
--locktree_manager::out_of_locks

```

#2.single txn

```cpp
locktree 有一个为 single txn 做的优化，当系统猜测当前是工作在 single txn 的方式下（不存在锁竞争的问题），所有的锁都会被 grant 并记录在 sto_buffer 里面。

如果不是 single txn 的模式，已经 grant 的锁则保存在 concurrent_tree 里面，这个就是我们在前面提到的那个 binary search tree。

Single txn 模式的判断是用启发式的方法，由两个因素控制 sto_buffer 和 concurrent_tree 的切换: 积分 score 和 sto_buffer 长度，因篇幅有限这块也留给大家分析了。要提的一点是如果正处在 single txn 模式，遇到了一个新的 txn，那么 sto_buffer 的锁会被转移到 concurrent_tree 上。
```

#3.