#1.os_event_t InnoDB条件变量

```cpp
/*
InnoDB条件变量
如果在InnoDB层直接使用系统条件变量的话，主要有四个弊端，首先，弊端1，系统条件变量的使用需要与一个系统互斥锁（详见下一节）相配合使用，使用完还要记得及时释放，使用者会比较麻烦。接着，弊端2，在条件等待的时候，需要在一个循环中等待，使用者还是比较麻烦。最后，弊端3，也是比较重要的，不方便系统监控。

基于以上几点，InnoDB基于系统的条件变量和系统互斥锁自己实现了一套条件通知机制。主要在文件os0sync.cc中实现，相关数据结构以及接口进一层的包装在头文件os0sync.h中。使用方法如下：

InnoDB条件变量核心数据结构为os_event_t，类似pthread_cont_t。如果需要创建和销毁则分别使用os_event_create和os_event_free函数。需要等待某个条件变量，先调用os_event_reset（原因见下一段），然后使用os_event_wait，如果需要超时等待，使用os_event_wait_time替换os_event_wait即可，os_event_wait_XXX这两个函数，解决了弊端1和弊端2，此外，建议把os_event_reset返回值传给他们，这样能防止多线程情况下的无限等待（详见下下段）。如果需要发出一个条件通知，使用os_event_set。这个几个函数，里面都插入了一些监控信息，方便InnoDB上层管理。怎么样，方便多了吧~
*/
```

#2.多线程环境下可能发生的问题

```cpp
首先来说说两个线程下会发生的问题。创建后，正常的使用顺序是这样的，线程A首先os_event_reset（步骤1），然后os_event_wait（步骤2），接着线程B做完该做的事情后，执行os_event_set（步骤3）发送信号，通知线程A停止等待，但是在多线程的环境中，会出现以下两种步骤顺序错乱的情况：乱序A： 步骤1--步骤3--步骤2，乱序B: 步骤3--步骤1--步骤2。对于乱序B，属于条件通知在条件等待之前发生，目前InnoDB条件变量的机制下，会发生无限等待，所以上层调用的时候一定要注意，例如在InnoDB在实现互斥锁和读写锁的时候为了防止发生条件通知在条件等待之前发生，在等待之前对lock_word 再次进行了判断，详见InnoDB自旋互斥锁这一节。为了解决乱序A，InnoDB在核心数据结构os_event 中引入布尔型变量is_set，is_set 这个变量就表示是否已经发生过条件通知，在每次调用条件通知之前，会把这个变量设置为true（在os_event_reset时改为false，便于多次通知），在条件等待之前会检查一下这变量，如果这个变量为true，就不再等待了。所以，乱序A也能保证不会发生无限等待。

接着我们来说说大于两个线程下可能会发生的问题。线程A和C是等待线程，等待同一个条件变量，B是通知线程，通知A和C结束等待。考虑一个乱序C：线程A执行os_event_reset（步骤1），线程B马上就执行os_event_set（步骤2）了，接着线程C执行了os_event_reset（步骤3），最后线程A执行os_event_wait（步骤4），线程C执行os_event_wait（步骤5）。乍一眼看，好像看不出啥问题，但是实际上你会发现A和C线程在无限等待了。原因是，步骤2，把is_set这个变量设置为false，但是在步骤3，线程C通过reset又把它给重新设回false了…… 然后线程A和C在os_event_wait中误以为还没有发生过条件通知，就开始无限等待了。为了解决这个问题，InnoDB在核心数据结构os_event中引入64位整形变量signal_count，用来记录已经发出条件信号的次数。每次发出一个条件通知，这个变量就递增1。os_event_reset的返回值就把当前的signal_count 值取出来。os_event_wait如果发现有这个参数的传入，就会判断传入的参数与当前的signal_count 值是否相同，如果不相同，表示这个已经通知过了，就不会进入等待了。举个例子，假设乱序C，一开始的signal_count 为100，步骤1把这个参数传给了步骤4，在步骤4中，os_event_wait会发现传入值100与当前的值101（步骤2中递增了1）不同，所以线程A认为信号已经发生过了，就不会再等待了。然而，线程C呢？步骤3返回的值应该是101，传给步骤5后，发生于当前值一样，继续等待。仔细分析可以发现，线程C是属于条件变量通知发生在等待之前（步骤2，步骤3，步骤5），上一段已经说过了，针对这种通知提前发出的，目前InnoDB没有非常好的解法，只能调用者自己控制。

总结一下， InnoDB条件变量能方便InnoDB上层做监控，也简化了条件变量使用的方法，但是调用者上层逻辑必须保证条件通知不能过早的发出，否则就会有无限等待的可能。
```